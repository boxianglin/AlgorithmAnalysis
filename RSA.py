# -*- coding: utf-8 -*-
"""350hw11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UxZbvU7zaLN6HZsACp95RNrh28M3qawz
"""

"""
Name: Boxiang Lin
HW11 Question 1
04/25/2022
"""

import math

def getPrimefactors(n):
  # @NOTE: So hard I reference online about efficient primefactor algorithm.
  primeFactors = []
  #even number divisible
  while n % 2 == 0:
    primeFactors.append(2)  # 2 is prime but 2*x is not prime.
    n = n / 2

  # check for all odd [3,sqrt(n)]
  for i in range(3,int(math.sqrt(n))+1,2):
    while (n % i == 0):
      primeFactors.append(i)
      n = n / i

  if n > 2:
    primeFactors.append(n)
  return primeFactors

def findPQ(n):
  """[Sort the primeFactors list and use two pointer to obtain the P and Q]
  """
  primeFactors = getPrimefactors(n)
  primeFactors.sort()
  l, r = 0, len(primeFactors)-1
  #      P          Q
  PQ = [float('-inf'), float('-inf')] 
  while l < r:
    ans = primeFactors[l]*primeFactors[r]
    if ans > n:
      r -= 1
    elif ans < n:
      l += 1
    else:
      sum1 = primeFactors[l] + primeFactors[r]
      sum2 = PQ[0] + PQ[1]
      if sum1 >= sum2:
        PQ[0], PQ[1] = primeFactors[l], primeFactors[r]
      l += 1
      r -= 1
  return (int(PQ[0]), int(PQ[1]))

def getPrivateKey(e, P, Q, n):
  # e*d mod phi= 1
  # where in  multiplicative inverseï¼š ed identicalTo (1 mod phi)
  # @Note: So hard I reference online: https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
  def egcd(a, b):
    if a == 0:
      return (b, 0, 1)
    else:
      g, y, x = egcd(b % a, a)
      return (g, x - (b // a) * y, y)

  def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
      raise Exception('modular inverse does not exist')
    else:
      return x % m
  phi = (P-1)*(Q-1)
  d = modinv(e, phi)
  return (d, n)

def getDecryptedWord(word, privateKey):
  # M = (C^d mod n)
  d, n = privateKey
  AsciiWordLst= []
  for c in word:
    ci = babyASCII[c]
    AsciiWordLst.append(ci)
  Cint = int("".join(AsciiWordLst))
  Mint = pow(Cint,d,n)
  currentM = []
  for v in str(Mint):
    c = babyASCII[v]
    currentM.append(c)
  return "".join(currentM)


def decryptRSA(cipherText, e, n):
  print("-------------------------- Start the decryptRSA -------------------------------------")
  P, Q = findPQ(n)
  print("P computed: ", P, "\tQ computed: ", Q)
  print("Its known that public key (e, n):", (e,n))

  privateKey = getPrivateKey(e, P, Q, n)
  print("Computed for private key (d, n):", privateKey)

  # decrypt word by word
  cipherList = cipherText.split()
  answer = []
  for word in cipherList:
    currentM = getDecryptedWord(word, privateKey)
    answer.append(currentM)
  return " ".join(answer)

def main():
  e = 49
  n = 10539750919
  cipherText = "ITG!AAEXEX IRRG!IGRXI OIXGEREAGO"
  print("Problem Given: ")
  print("Given e: ", e)
  print("Given n: ", n)
  print("Given cipherText: ", cipherText)


  answer = decryptRSA(cipherText, e, n)
  print("Decrpyted Successfully: ", answer)

def getBidirectASCII():
  babyASCII1 = {'A':'1', 'E':'2', 'G':'3', 'I':'4', 'O':'5', 'R':'6', 'T':'7', 'X':'8',
               '!':'9', '0':'0'}
  babyASCII2 = {val:key for key, val in babyASCII1.items()}
  babyASCII = dict(babyASCII1.items() | babyASCII2.items())
  return babyASCII

if __name__ == "__main__":
  babyASCII = getBidirectASCII()
  main()